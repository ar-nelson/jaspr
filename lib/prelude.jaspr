{
  jaspr: "0.0.91"
  module: "prelude"

  export: [
    par let closure apply fn* fn1 fn2 \* \ \2 \_ λ* λ λ2 λ_ partial η macroexpand macro-get

    boolean? null? if and or no is? isnt?

    number? + - * div mod

    string? print to-string to-json from-json str strlen substr

    array? array length slice take drop concat hd tl last init cons snoc zip for map
    filter fold-left fold-right fold reduce flatten flat-map

    object? object merge assoc dissoc update keys values entries
  ]

  macros: {
    closure: '{
      ⚙scope: {}
      fn: `(⚙objectMerge
        (⚙extendScope ~(0 ⚙args))
        {fn: (⚙macroexpand (~null ~(1 ⚙args)))})
    }
    let: (closure {} `((closure, ~@⚙args)))
    fn*: (closure {} `(closure {} (let {args: ⚙args} ~(0 ⚙args))))
    fn1: (fn* `(closure {}
      (let ~(object (array (0 args) '(0 ⚙args)))
           ~(1 args))))
    fn2: (fn* `(closure {}
      (let ~(object (array (0 args) '(0 ⚙args))
                    (array (1 args) '(1 ⚙args)))
           ~(2 args))))
    macro-get: (fn1 x `(⚙macroget ~x))
    \*: (macro-get fn*)
    λ*: (macro-get fn*)
    \: (macro-get fn1)
    λ: (macro-get fn1)
    \2: (macro-get fn2)
    λ2: (macro-get fn2)
    \_: (λ body `(λ _ ~body))
    λ_: (macro-get \_)
    macroexpand: (λ_ `(⚙macroexpand ~_))
    partial: (λ* `(λ* (apply ~(hd args) (join ~(tl args) args))))
    η: (macro-get partial)
    
    if: (λ* (⚙if (≤ (length args) 4)
              (cons '⚙if args)
              `(⚙if ~(0 args) ~(1 args) ~(cons 'if (drop 2 args)))))
    and: (λ* (if args `(if ~(hd args) (and ~@(tl args)) false)
                      true))
    or: (λ* (if args `(if ~(hd args) (or ~@(tl args)) true)
                     false))
  }
  defs: {
    par: '{⚙scope: {} fn: null}
    array: '{⚙scope: {} fn: ⚙args}
    object: '{⚙scope: {} fn: (⚙makeObject ⚙args)}
    is?: (λ2 a b (⚙equals a b))
    null?: (λ_ (is? _ null))
    boolean?: (λ_ (⚙isBoolean _))
    number?: (λ_ (⚙isNumber _))
    string?: (λ_ (⚙isString _))
    array?: (λ_ (⚙isArray _))
    object?: (λ_ (⚙isObject _))
    no: (λ_ (⚙if _ false true))
    isnt?: (λ2 a b (no (is? a b)))
    to-string: (λ_ (⚙toString _))
    to-json: (λ_ (⚙toJson _))
    from-json: (λ_ (⚙fromJson _))
    print: (λ_ (⚙print _))
    apply: (λ2 fn args (⚙apply fn args))
    
    // Array functions
    length: (λ_ (⚙arrayLength _))
    slice: (λ* (⚙arraySlice (2 args) (0 args) (1 args)))
    take: (λ2 n xs (slice 0 n xs))
    drop: (λ2 n xs (slice n (length xs) xs))
    concat: (λ* (reduce (λ2 a b `[~@a ~@b]) [] args))
    hd: 0
    tl: (λ_ (drop 1 _))
    last: -1
    init: (λ xs (take (- (length xs) 1) xs))
    cons: (λ2 h t `[~h ~@t])
    snoc: (λ2 i l `[~@i ~l])
    zip: (λ2 xs ys
      (if (no xs) []
          (no ys) []
                  (cons (array (hd xs) (hd ys))
                        (zip (tl xs) (tl ys)))))
    for: (λ2 f xs
      (if xs (par (f (hd xs))
                  (for f (tl xs)))
             null))
    map: (λ2 f xs
      (if xs (cons (f (hd xs))
                   (map f (tl xs)))
             []))
    filter: (λ2 f xs
      (if (no xs)     []
          (f (hd xs)) (cons (hd xs) (filter f (tl xs)))
                      (filter f (t xs))))
    fold-right: (fn*
      (let {f: (0 args) init: (1 args) xs: (2 args)}
           (if xs (f (hd xs) (fold-right f init) (tl xs))
                  init)))
    fold-left: (fn*
      (let {f: (0 args) init: (1 args) xs: (2 args)}
           (if xs (fold-left f (f init (hd xs)) (tl xs))
                  init)))
    fold: fold-left
    reduce: fold-left
    flatten: (λ_ (if _ (concat (hd _) (flatten (tl _))) []))
    flat-map: (λ2 f xs (flatten (map f xs)))

    // Number functions
    +: (λ* (reduce (λ2 a b (⚙add a b)) 0 args))
    *: (λ* (reduce (λ2 a b (⚙multiply a b)) 1 args))
    -: (λ* (if (is? 1 (length args))
             (⚙negate (0 args))
             (reduce (λ2 a b (⚙subtract a b)) (hd args) (tl args))))
    div: (λ2 a b (⚙divide a b))
    mod: (λ2 a b (⚙modulus a b))
    <: (λ2 a b (⚙less a b))
    <=: (λ2 a b (⚙lessOrEqual a b))
    >: (λ2 a b (⚙less b a))
    >=: (λ2 a b (⚙lessOrEqual b a))
    ≤: <=
    ≥: >=

    // String functions
    str: (λ* (reduce (λ2 a b (⚙stringJoin a b)) "" args))
    strlen: (λ2 a b (⚙stringLength a b))
    substr: (λ* (⚙stringSlice (0 args) (1 args)
                  (if (is? 2 (length args)) (strlen (0 args))
                                            (2 args))))
    
    // Object functions
    merge: (λ* (reduce (λ2 a b (⚙objectMerge a b)) {} args))
    assoc: (λ* (merge (0 args) (object (array (1 args) (2 args)))))
    dissoc: (λ2 o k (⚙objectDelete o k))
    update: (λ* (let {o: (0 args) k: (1 args)}
                     (merge o (object (array k ((2 args) (k o)))))))
    keys: (λ_ (⚙objectKeys _))
    values: (λ x (map (λ k (k x)) (keys x)))
    entries: (λ x (map (λ k (array k (k x))) (keys x)))
  }
}