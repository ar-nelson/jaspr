$schema: “http://adam.nels.onl/schema/jaspr/module”
$module: “prelude”

; -------------------------------------------------------------------
; ⚠ WARNING: This file almost certainly won't compile right now.
;             It's a work in progress.
; -------------------------------------------------------------------

$doc: “
  The default, automatically-loaded standard library (“prelude”) for the Jaspr
  language. Defines basic functions for working with the 6 JSON data types, as
  well as control flow and pattern matching macros.
”
$author: “Adam R. Nelson <adam@nels.onl>”

$export: {
  closure let

  fn* \ \x \y \z \xy
  λ:\ λx:\x λy:\y λz:\z λxy:\xy

  id const apply curry uncurry partial eta η:eta

  macroexpand eval scope-get gensym! throw comment ⍝:comment not-implemented
  quote

  null? boolean? number? string? array? object? closure? proc?

  len slice take drop take-right drop-right ++ hd tl last init cons snoc nil?
  ⧺:++

  and or and? or? xor? no all? any? none?
  ∧:and? ∨:or? ⊕:xor? ¬:no ∀:all? ∃:any? ∄:none?

  eq? = != ≠:!= if loop-as
  
  compare-numbers compare-strings compare-arrays compare-objects compare-json
  compose-comparators sort-by sort /* sorted-by? sorted? */

  -> ->> \-> \->>
  →:-> ↠:->> λ→:\-> λ↠:\->>

  par seq

  has? get get-or put update

  for-range for-range-seq make-array
  for-each for-each-seq for-each-right-seq map filter reject
  fold-right fold-left fold:fold-left reduce:fold-left
  flatten flatten-deep flat-map zip unzip
  take-while drop-while take-right-while drop-right-while remove remove-where
  find find-last index-of last-index-of indexes-of indices-of contains contains-all?
  range indexes indices reverse replicate unfold
  uniq uniq? union interection intersect:intersection difference
  count count-by group-by split intercalate chunk

  ∈:contains? ⊆:contains-all ∪:union ∩:intersection ∆:difference

  + * - div mod pow sqrt < <= > >= integer? infinite? ∞? NaN? Infinity -Infinity
  NaN floor ceil round abs sign log log2 log10 pos? neg? even? odd? range sum
  product sin cos tan asin acos atan atan2 sinh cosh tanh asinh acosh atanh
  hypot cbrt
  pi π e sqrt2 √2 sqrt1/2 √½ ln2 ln10 log2e log10e even? odd?
  
  ×:* −:- ÷:div %:mod expt:pow ≤:<= ≥:>= ∞?:infinite? ∞:Infinity -∞:-Infinity
  ⌊:floor ⌈:ceil ±:sign ∑:sum ∏:product √:sqrt ∛:cbrt √2:sqrt2 √½:sqrt1/2

  str to-json from-json empty-string? empty-str?:empty-string?
  print! newline! print-line! println!:print-line! ⏎!:newline!

  byte unit char code-point bytes units chars code-points:chars
  to-bytes to-units to-chars to-code-points
  from-bytes from-units from-chars from-code-points lines words
  for-each-byte for-each-unit for-each-char for-each-code-point
  slice-bytes slice-units slice-chars
  normalize-NFD normalize-NFC normalize-NFKD normalize-NFKC
  upper-case lower-case title-case
  starts-with? ends-with? string-contains? str-contains?:string-contains?
  string-replace str-replace:string-replace trim
  unit-index-of last-unit-index-of char-index-of: last-char-index-of:
  unit-indexes-of unit-indices-of:unit-indexes-of
  char-indexes-of char-indices-of:char-indexes-of
  split-string split-str:split-string

  make-object keys values entries
  merge merge-with keys map-keys map-values
}

;; closure and let
;;
;; Core macros to define closures and scopes. Prerequisites for everything else
;; in this module.

macro.closure: '{$closure: {}, $code: `[$closure ~(0 $args) ~(1 $args) {}]}
macro.let: (closure {} `[(closure ~(0 $args) ~(1 $args))])

;; Simple function macros
;;
;; fn1, fn2, and fn* are used throughout this module to define simple functions
;; before the pattern-matching function macro fn is available.

macro.fn*:
  (closure {} `[closure {} (let ~({} (0 $args) '$args) ~(1 $args))])
macro.fn1:
  (fn* args `[closure {} (let ~({} (0 args) '(0 $args))
                              ~(1 args))])
macro.fn2:
  (fn* args `[closure {} (let ~({} (0 args) '(0 $args) (1 args) '(1 $args))
                              ~(2 args))])

;; Lambda macros
;;
;; These remove one level of parens. For example, (\ print _) becomes
;; (fn1 _ (print _)). The named lambdas \x, \y, and \z allow nesting with
;; different variable names. \xy is a two-argument lambda.

macro.\: (fn* body `[closure {} (let {_: (0 $args)} ~body)])
macro.\x: (fn* body `[closure {} (let {x: (0 $args)} ~body)])
macro.\y: (fn* body `[closure {} (let {y: (0 $args)} ~body)])
macro.\z: (fn* body `[closure {} (let {z: (0 $args)} ~body)])
macro.\xy: (fn* body `[closure {} (let {x: (0 $args) y: (1 $args)} ~body)])

;; Function combinators
;;
;; apply calls a function with an array of arguments. partial works like
;; Clojure's partial, returning a partially-applied version of a function with
;; some arguments filled in.

id: (\ _)
const: (\x \y x)
apply: (\xy $apply x y)
curry: (fn* xs (fn* ys (\ apply (hd xs) (snoc ys _))))
uncurry: (fn1 f (fn* args ((apply f (init args)) (last args))))

macro.partial: (fn* pre-args `[fn* post-args
  (apply ~(hd pre-args) (⧺ ~(tl pre-args) post-args))])

; η for “eta reduction”, the transformation from “λx. f x” to “f”
macro.eta: (fn* args `[closure {} ~(snoc args '(0 $args))])

;; Miscellaneous special forms
;;
;; macroexpand, eval, and scope-get depend on the current scope, and so must be
;; defined as macros.

macro.macroexpand: (fn1 code `[$macroexpand ~code])
macro.eval: (fn1 code `[$eval ~code])
macro.scope-get: (fn2 scope name `[$scope-get ~scope ~name])

gensym!: (closure {} ($gensym))
throw: (fn1 err ($throw err))

macro.comment: (closure {} null)
not-implemented: (\ closure {} (throw {err: (str “not implemented: ” _)}))

; quote is NOT the ' special form; that is the empty string (“”).
; Instead, quote is used in macros to generate the quoted form of a value.
;
;     (quote “foo”) ;= [“”, “foo”]
;
quote: (\ [] “” _)

;; Type predicates
;;
;; Instance-of functions for the 6 core JSON types, plus the Jaspr-specific
;; closure and proc types.

null?: (\ $equals _ null)
boolean?: (\ or ($equals true _) ($equals false _))
number?: (\ $is-number _)
string?: (\ $is-string _)
array?: (\ $is-array _)
object?: (\ $is-object _)
closure?: (\ and (object? _) (has? '$closure _))
proc?: (\ and (object? _) (has? '$proc _) (number? ('$proc _)))

;; Core array functions

len: (\ $array-length _)
nil?: (\ no ($array-length _))
slice: (fn* a ($array-slice (2 a) (0 a) (1 a)))
take: (fn2 n xs (slice 0 n xs))
drop: (fn2 n xs (slice n (length xs) xs))
++: (fn* args (apply $array-concat args))
hd: 0
tl: (\ drop 1 _)
last: -1
init: (\x take (- (len x) 1) x)
cons: (\xy ++ [x] y)
snoc: (\xy ++ x [y])

;; Boolean operations
;;
;; The and/or macros work identically to those in other Lisps, short-circuiting
;; as soon as possible. and? and or? are the function versions, which do not
;; short-circuit. Not is called no, as in Arc¹. all?, any?, and none? are
;; boolean folds, which take an array and a function.
;;
;; All of the boolean functions have Unicode versions, using the standard
;; logical operators.
;;
;; ┌─────────┰─────┬────┬──────┬─────┬──────┬────┬──────┬──────┬───────┐
;; │ ASCII   ┃ and │ or │ and? │ or? │ xor? │ no │ all? │ any? │ none? │
;; │ Unicode ┃     │    │ ∧    │ ∨   │ ⊕    │ ¬  │ ∀    │ ∃    │ ∄     │
;; └─────────┸─────┴────┴──────┴─────┴──────┴────┴──────┴──────┴───────┘
;;
;; ¹ http://www.paulgraham.com/arc.html

macro.and:
  (fn* args ($if args `[$if ~(hd args) (and ~@(tl args)) false]
                      true))
macro.or:
  (fn* args ($if args `[$if ~(hd args) true (or ~@(tl args))]
                      false))
and?:
  (fn* args ($if args ($if (hd args) (apply and? (tl args)) false)
                      true))
or?:
  (fn* args ($if args ($if (hd args) true (apply or? (tl args)))
                      false))
xor?:
  (fn* args
    ($if ($equals 1 (len args))
      (hd args)
      (and args (apply xor? (cons (no ($equals (0 args) (1 args))))
                            (drop 2 args)))))

no: (\ $if _ false true)
all?: (fn2 f xs (reduce (\xy and x (f y)) true xs))
any?: (fn2 f xs (reduce (\xy or x (f y)) false xs))
none?: (\xy no (any? x y))

;; Equality
;;
;; Although the magic form $equals only tests absolute (address) equality, all
;; Jaspr values are immutable, so the only kind of equality it officially
;; supports is structural equality, via eq? or =.
;;
;; Closures, because they may contain self-references, are the only exception.
;; Structural equality is not checked on closures; closures are only equal if
;; they are address-equal.

eq?: (\xy or ($equals x y)
             (and (array? x) (array? y)
                  ($equals (length x) (length y))
                  (all? (\ eq? (0 _) (1 _)) (zip x y)))
             (and (object? x) (object? y)
                  (no (closure? x)) (no (closure? y))
                  (all? (\ has? _ x) (keys y))
                  (all? (\ and (has? _ y) (eq? (_ x) (_ y))) (keys x))))

=: (fn* args (all? (eta eq? (hd args)) (tl args)))
!=: (fn* args (any? (\ no (eq? (hd args) _)) (tl args)))

;; If
;;
;; Jaspr takes another cue from Arc by making if the equivalent of other Lisps'
;; cond macro.
;;
;;     (if case-1 then-1
;;         case-2 then-2
;;         ⋯
;;         case-n then-n
;;         else)

macro.if:
  (fn* args
    ($if (<= (length args) 4)
        (cons '$if args)
        `[$if ~(0 args) ~(1 args) ~(cons 'if (drop 2 args))]))

;; Comparisons
;;
;; A comparator is a function that takes two arguments (x, y) and returns:
;;
;; - 1 if x > y
;; - 0 if x = y
;; - -1 if x < y
;; - NaN if x and y are not comparable
;; 
;; It should not return any other values, and should not throw exceptions.
;; Comparators can be chained with compose-comparators, which applies each
;; comparator in a sequence until one of them returns 1 or -1, then returns 0 if
;; any returned 0, NaN otherwise.
;;
;; compare-json is the default comparator; it can compare any two JSON values
;; (null < false < true < numbers < strings < arrays < objects), and never
;; returns NaN.

compare-numbers:
  (\xy if (and (number? x) (number? y))
          (sign (- y x))
          NaN)
compare-strings:
  (\xy if (and (string? x) (string? y))
          ($string-compare x y)
          NaN)
compare-arrays:
  (\xy if (and (array? x) (array? y))
          (if (nil? x) (if (nil? y) 0 -1)
              (nil? y) 1
              ((compose-comparators
                 (\xy compare-json (hd x) (hd y))
                 (\xy compare-arrays (tl x) (tl y))) x y))
          NaN)
compare-objects:
  (\xy if (and (object? x) (object? y) (no (closure? x)) (no (closure? y)))
          (let {
            kx: (sort-by compare-strings (keys x)),
            ky: (sort-by compare-strings (keys y))
          } (if (nil? kx) (if (nil? ky) 0 -1)
                (nil? ky) 1
                ((compose-comparators
                   compare-arrays
                   (fn2 kx ky (compare-arrays (map (\ _ x) kx)
                                              (map (\ _ y) ky)))) kx ky)))
          NaN)
type-compare-index: ; Private function for comparing different types
  (\ if (null? _) 0
        (boolean? _) (if _ 2 1)
        (number? _) 3
        (string? _) 4
        (array? _) 5
        (closure? _) NaN
        /* object? */ 6)
compare-json:
  (compose-comparators
    compare-numbers
    compare-strings
    compare-arrays
    compare-objects
    (\xy compare-numbers (type-compare-index x) (type-compare-index y)))

compose-comparators:
  (fn* cmps
    (\xy loop-as continue {i: 0, any-0: false}
      (if (>= i (len cmps))
          (if any-0 0 NaN)
          (let {result: ((i cmps) x y)}
            (if (or (= result 1) (= result -1))
                result
                (continue {i: (+ 1 i), any-0: (or any-0 (= result 0))}))))))

;; Sorting

sort-by:
  (fn2 cmp xs
    (if (> (len xs) 1)
        (let {
          pivot: (-> xs len (div 2) floor) ; TODO: select randomly instead
          y: (pivot xs)
          choose: (fn2 p x
                    (let {
                      c: (cmp x y)
                      k: (if (< c 0) '<
                             (> c 0) '>
                             (= c 0) '=
                             (throw {err: “cannot compare”,
                                     comparator: cmp, x, y}))
                    } (update (eta cons x) k p)))
          parts: (reduce choose {<: [], =: [], >: []} xs)
        } (++ (sort-by cmp ('< parts)) ('= parts) (sort-by cmp ('> parts))))
        xs))
sort: (eta sort-by compare-json)

;; Threading macros
;;
;; The arrow macros -> and ->> are borrowed from Clojure; they thread a value
;; through a sequence of functions, with the result of each as either the first
;; (->) or last (->>) argument of the next.
;;
;; The lambda variants \-> and \->> thread the lambda argument through the
;; functions.

macro.->:
  (fn* args
    (if (> (len args) 1)
          (let {arg: (0 args) f: (1 args) rest: (drop 2 args)}
            `[-> ~(if (and f (array? f)) `[~(hd f) ~arg ~@(tl f)]
                                         `[~f ~arg])
                 ~@rest])
        args
          (hd args)
        (throw {err: “-> takes at least 1 argument”})))
macro.->>:
  (fn* args
    (if (> (len args) 1)
          (let {arg: (0 args) f: (1 args) rest: (drop 2 args)}
            `[->> ~((if (and f (array? f)) snoc []) f arg)
                  ~@rest])
        args
          (hd args)
        (throw {err: “->> takes at least 1 argument”})))
macro.\->: (fn* args `[\ -> _ ~@args])
macro.\->>: (fn* args `[\ ->> _ ~@args])

doc.loop-as: “
  `loop-as` is the idiomatic way to use an inline recursive function as a loop.
  It takes a function name and an object; the function name and the object's
  keys are included in the scope, the object is used as the initial argument.

  For example, this computes `5!`:

      (loop-as factorial {n: 5}
        (if (< n 1) n (* n (factorial {n: (- n 1)}))))
”
macro.loop-as:
  (fn* spec
    (let {name: (0 spec), args: (1 spec), body: (2 spec)}
      `[let ~(object name `[closure {}
           (let ~(map-values (fn2 v k `[~(quote k) (0 $args)]) args) ~body)])
         (~name ~args)]))

;; Async combinators
;;
;; par and seq are the parallel and sequential versions of what Scheme calls
;; “begin” or Common Lisp calls “progn”: functions/macros that execute blocks
;; of code for their side effects, then return the value of the last expression.
;; Both only return once the return values of all expressions have resolved.

par:
  (fn* exprs (->> exprs (map const) (fold-right (\xy $then x y) id)))
macro.seq:
  (fn* exprs
    (->> exprs
         (map (fn1 x `[closure {} ~x]))
         (fold-right (fn2 x y `[$then ~x ~y]) `id)))

;; Member access
;;
;; get chains accessors, to look up values nested deep in a data structure. The
;; structure is the last argument.
;; get-or is the same, but its first argument is an alternative return value if
;; the lookup fails.
;; has? returns whether a chain of keys/indexes is present.

get:
  (fn* args
    (if (no args)
          (throw {err: “get takes at least 1 argument”, args})
        (= 1 (len args))
          (hd args)
        (apply get (snoc (slice 1 (- (len args) 1) args)
                         ((hd args) (last args))))))
has?:
  (fn* args
    (if (= (len args) 2)
          (let {key: (0 args), it: (1 args)}
            (or (and (object? it) ($object-has key it))
                (and (array? it) (integer? key)
                     (< -1 (if (< key 0) (+ (len it) key) key) (len it)))))
        (< (len args) 2)
          (throw {err: “has? takes at least 2 arguments”, args})
        (let {next-key: (hd args), it: (last args)}
          (and (has? next-key it)
               (apply has? (snoc (slice 1 (- (len args) 1) args)
                                 (next-key it)))))))

get-or:
  (fn* args
    (if (< (len args) 3)
        (throw {err: “get-or takes at least 3 arguments”, args})
        (let {lookup: (tl args)}
          (if (apply has? lookup) (apply get lookup) (hd args)))))

;; Functional update
;;
;; put and update both perform functional updates on nested data structures,
;; returning a modified version of the structure with one element changed.
;; Put sets a value directly, while update applies a function to the value.
;;
;; Both take the value/function as the first argument, then a sequence of keys,
;; and finally the structure to update.

update:
  (fn* args
    (if (= (len args) 2) ((0 args) (1 args))
        (< (len args) 2) (throw {err: “update takes at least 2 arguments”, args})
        (let {
          k: (1 args)
          it: (last args)
          next-args: (cons (hd args) (slice 2 (- (len args) 1) args))
        } (if (object? it)
                ($object-put k (apply put (snoc next-args (k it))))
              (array? it)
                (let {n: (if (< k 0) (+ (len it) k) k)}
                  (++ (take n it)
                      ([] (apply update (snoc next-args (n it))))
                      (drop (+ 1 n) it)))
              (throw {
                err: “last argument of update must be an object or array”
                args
              })))))
put:
  (fn* args (apply update (cons (const (hd args)) (tl args))))

;; Higher-order array functions

for-range:
  (fn2 f n (if (> n 0) (par (f n) (for-range f (- n 1))) (f n)))
for-range-seq:
  (fn2 f n (if (> n 0) (seq (f n) (for-range-seq f (- n 1))) (f n)))
make-array:
  (fn2 f sz ($make-array f sz))

for-each:
  (fn2 f xs (for-range (\ f (_ xs)) (len xs)))
for-each-seq:
  (fn2 f xs (for-range-seq (\ f (_ xs)) (len xs)))
for-each-right-seq:
  (fn2 f xs (for-range-seq (\ f ((_) xs)) (len xs)))
map:
  (fn2 f xs (make-array (\ f (_ xs)) (len xs)))
filter:
  (fn2 f xs
    (if (no xs)     []
        (f (hd xs)) (cons (hd xs) (filter f (tl xs)))
                    (filter f (t xs))))
fold-right:
  (fn* args
    (let {f: (0 args) init: (1 args) xs: (2 args)}
        (if xs (f (hd xs) (fold-right f init (tl xs)))
                init)))
reduce:
  (fn* args
    (let {f: (0 args) init: (1 args) xs: (2 args)}
        (if xs (reduce f (f init (hd xs)) (tl xs))
                init)))
flatten: (\ if _ (++ (hd _) (flatten (tl _))) [])
flatten-deep: (not-implemented “flatten-deep”)
flat-map: (fn2 f xs (flatten (map f xs)))
range: (eta make-array id)
indexes: (\->> len range)
zip:
  (\xy if (or (no x) (no y)) []
          (cons ([] (hd x) (hd y))
                (zip (tl x) (tl y))))
split:
  (fn2 delim xs
    (fold-right (fn2 x accum
        (if (= delim x) (cons [] accum)
                        (cons (cons x (hd accum)) (tl accum))))
      '[[]] xs))

;; Core number functions

+: (fn* args (reduce (\xy $add x y) 0 args))
*: (fn* args (reduce (\xy $multiply x y) 1 args))
-: (fn* args (if ($equals 1 (len args))
                 ($negate (0 args))
                 (reduce (\xy $subtract x y) (hd args) (tl args))))
div: (\xy $divide x y)
mod: (\xy $modulus x y)
pow: (\xy $pow x y)
sum: (eta apply +)
product: (eta apply *)
sqrt: (eta $sqrt)
cbrt: (eta $cbrt)

<:
  (fn* xs (all? (\ $less (_ xs) ((+ _ 1) xs))
                (range (- (len args) 1))))
<=:
  (fn* xs (all? (\ $less-or-equal (_ xs) ((+ _ 1) xs))
          (range (- (len args) 1))))
>:
  (fn* xs (all? (\ $less ((+ _ 1) xs) (_ xs))
                (range (- (len args) 1))))
>=:
  (fn* xs (all? (\ $less-or-equal ((+ _ 1) xs) (_ xs))
                (range (- (len args) 1))))

integer?: (\ and (number? _) (no (NaN? _)) (no (infinite? _)) (= _ (floor _)))
infinite?: (eta $is-infinite)
NaN?: (eta $is-NaN)
Infinity: $infinity
-Infinity: $negative-infinity
NaN: $NaN

floor: (eta $floor)
ceil: (eta $ceil)
round: (eta $round)
abs: (eta $abs)
sign: (\ if (pos? _) 1 (neg? _) -1 (NaN? _) NaN 0)
pos? (eta < 0)
neg? (eta > 0)
even?: (\-> (mod 2) (= 0))
odd?: (\-> (mod 2) (= 1))


log: (eta $log)
log2: (eta $log2)
log10: (eta $log10)
sin: (eta $sin)
cos: (eta $cos)
tan: (eta $tan)
asin: (eta $asin)
acos: (eta $acos)
atan: (eta $atan)
atan2: (\xy $atan2 x y)
sinh: (eta $sinh)
cosh: (eta $cosh)
tanh: (eta $tanh)
asinh: (eta $asinh)
acosh: (eta $acosh)
atanh: (eta $atanh)
hypot: (\xy $hypot x y)

pi: 3.141592653589793
e: 2.718281828459045
sqrt2: 1.4142135623730951
sqrt1/2: 0.7071067811865476
ln2: 0.6931471805599453
ln10: 2.302585092994046
log2e: 1.4426950408889634
log10e: 0.4342944819032518

;; Core string functions
;;
;; Jaspr's approach to strings is much more Unicode-aware than that of most
;; languages. Strings can be iterated over in 4 ways:
;;
;; • By bytes, in UTF-8
;; • By “units”, the 16-bit code points used in languages like JS and Java that
;;   split up surrogate pairs (this is only useful for performance)
;; • By “chars”, 32-but Unicode characters
;; • By “code-points”, 32-bit Unicode code points as numbers

str: (fn* args (reduce (\xy $string-concat x ($to-string y)) “” args))
to-json: (eta $to-json)
from-json: (eta $from-json)
empty-string?: (eta $equals “”)

print!: (fn* args ($print (apply str args)))
newline!: (closure {} ($print “\n”))
print-line!: (fn* args (seq (apply print! args) (newline!)))

byte: (not-implemented “byte”)
unit: (\xy $native-char-at x y)
char: (\xy $unicode-char-at x y)
code-point: (\xy $unicode-code-point-at x y)

bytes: (not-implemented “bytes”)
units: (eta $string-native-length)
chars: (eta $string-unicode-length)

to-bytes: (not-implemented “to-bytes”)
to-units: (\x map (\y unit y x) (range (units x)))
to-chars: (\x map (\y char y x) (range (chars x)))
to-code-points: (\x map (\y code-point y x) (range (code-points x)))

from-bytes: (not-implemented “from-bytes”)
from-units: (eta $string-from-native-chars)
from-chars: str
from-code-points: (\->> (map (eta $unicode-chr)) from-chars)

lines:
  (\->> (split-string “\n”)
        (map (\ let {n: (- (units _) 1)}
                  (if (= “\r” (unit n _)) (slice-units 0 n _) _))))
words: (not-implemented “words”)

for-each-byte: (not-implemented “for-each-byte”)
for-each-unit: (not-implemented “for-each-unit”)
for-each-char: (not-implemented “for-each-char”)
for-each-code-point: (not-implemented “for-each-code-point”)

slice-bytes: (not-implemented “slice-bytes”)
slice-units: (fn* a $substring (0 a) (1 a) (2 a))
slice-chars: (not-implemented “slice-chars”)

normalize-NFD: (eta $nfd)
normalize-NFC: (eta $nfc)
normalize-NFKD: (eta $nfkd)
normalize-NFKC: (eta $nfkc)

upper-case: (not-implemented “upper-case”)
lower-case: (not-implemented “lower-case”)
title-case: (not-implemented “title-case”)

starts-with?:
  (fn2 prefix x
    (let {pl: (units prefix)}
      (and (>= (units x) len-p)
           (= prefix (slice-units 0 len-p x)))))
ends-with?:
  (fn2 suffix x
    (let {sl: (units suffix), xl: (units x)}
      (and (>= xl sl)
           (= suffix (slice-units (- xl sl) xl x)))))
str-contains?: (\xy $string-contains x y)
string-contains?: str-contains?
str-replace: (fn old new str ($string-replace old new str))
string-replace: str-replace
trim: (not-implemented “trim”)
unit-index-of:
  (fn needle haystack ($string-index-of needle 0 haystack)
    | needle start-at haystack ($string-index-of needle start-at haystack))
last-unit-index-of:
  (fn needle haystack ($string-last-index-of needle (units haystack) haystack)
    | needle start-at haystack ($string-last-index-of needle start-at haystack))
char-index-of:
  (fn needle haystack (char-index-of needle 0 haystack)
    | needle start-at haystack
        (let {in-units: (unit-index-of needle start-at haystack)}
          (if (>= in-units 0) (chars (slice-units 0 in-units haystack))
                              in-units)))
last-char-index-of:
  (fn needle haystack (last-char-index-of needle (units haystack) haystack)
    | needle start-at haystack
        (let {in-units: (last-unit-index-of needle start-at haystack)}
          (if (>= in-units 0) (chars (slice-units 0 in-units haystack))
                              in-units)))
unit-indexes-of:
  (fn needle haystack (unit-indexes-of needle 0 haystack)
    | needle start-at haystack
        (let {loop: (\x let {
            start: (+ 1 (apply max (cons (- start-at 1) x)))
            next: (unit-index-of needle start haystack)
          } (if (>= next 0) (loop (snoc x next)) x))
        } (loop [])))
char-indexes-of:
  (fn needle haystack (char-indexes-of needle 0 haystack)
    | needle start-at haystack
        (map (\ chars (slice-units 0 _ haystack))
             (unit-indexes-of needle start-at haystack)))
split-str: (\xy $string-split x y)
split-string: split-str

;; Core object functions

merge: (fn* args (reduce (\xy $object-merge x y) {} args))
keys: (eta $object-keys)
values: (\x map (\y y x) (keys x))
entries: (\x map (\y array y (y x)) (keys x))

;; Pattern matching
;;
;; case and fn use the following pattern matching syntax:
;;
;; null, true, false, <number>, '<string> -
;;   A literal value, which matches only itself.
;;
;; <string> -
;;   A variable, which matches anything and binds the variable.
;;
;; '[x-0 x-1 ⋯ x-n] -
;;   Matches a list with exactly n+1 elements. Note that the list MUST be
;;   quoted, even if it is nested inside another quoted list.
;;
;; {k-0: v-0 k-1: v-1 ⋯ k-n: v-n} -
;;   Matches an object with at least the given keys. Extra, unspecified keys
;;   are allowed but ignored. May or may not be quoted.
;;
;; TODO: Support deconstructors via unquoted lists.
;;       It should be possible to match a list as (cons x xs).

test-pattern:
  (fn2 pattern value
    (if (or (no pattern) (boolean? pattern) (number? pattern))
          (= pattern value)
        (string? pattern)
          true
        (and (array? pattern) (empty-string? (0 pattern)))
          (let {qp: (1 pattern)}
            (if (array? qp)
                  (and (array? value)
                       (= (len qp) (len value))
                       (all? (\ test-pattern (0 _) (1 _)) (zip qp value)))
                (object? qp)
                  (test-pattern qp value)
                ; else
                  (= qp value)))
        (object? pattern)
          (and (object? value)
               (all? (\ and (has? (0 _) value)
                            (test-pattern (1 _) ((0 _) value)))
                     (entries pattern)))
        (throw {err: “bad pattern”, pattern})))

pattern-scope:
  (fn2 pattern value
    (if (or (no pattern) (boolean? pattern) (number? pattern))
          {}
        (string? pattern)
          ({} pattern value)
        (and (array? pattern) (empty-string? (0 pattern)))
          (let {qp: (1 pattern)}
              (if (array? qp)
                    (apply merge (map (\ pattern-scope (1 _) ([] (0 _) value))
                                      (zip (indexes qp) qp)))
                  (object? qp)
                    (pattern-scope qp value)
                  {}))
        (object? pattern)
          (apply merge (map (\ pattern-scope (1 _) ([] (quote (0 _)) value))
                            (entries pattern)))
        (throw {err: “bad pattern”, pattern})))

;; (match-pattern pattern value then-case else-case)
;;
;; Matches “value” against “pattern”. If the match succeeds, executes
;; “then-case” with all pattern variables in scope; otherwise, executes
;; “else-case”.

macro.match-pattern:
  (fn* args
    (let { pattern: (0 args), value: (1 args)
           then-case: (2 args), else-case: (3 args) }
      (if (string? pattern) `[let ~({} pattern value) ~then-case]
          (let {
            code: (fn1 x `[if (test-pattern ~(quote pattern) ~x)
                              (let ~(pattern-scope pattern x) ~then-case)
                              ~else-case])
          } (if (string? value)
                (code value)
                (let {x: (gensym!)} `[let ~({} x value) ~(code x)]))))))

;; (case value pattern-0 branch-0 ⋯ pattern-n branch-n)
;;
;; Matches “value” against “pattern-0”…“pattern-n”, and runs the branch
;; corresponding to the first pattern that matches.

macro.case:
  (fn* args
    (if (even? (len args))
          (throw {err: “wrong number of args for case”, args})
        (= 1 (len args))
          null
        (let {
          value: (0 args)
          code: (fn1 x
            `[match-pattern ~(1 args) ~x ~(2 args) (case ~x ~@(drop 3 args))])
        } (if (string? value)
              (code value)
              (let {x: (gensym)} `(let ~({} x value) ~(code x)))))))

;; (fn arg-0-0 ⋯ arg-0-n body-0 | ⋯ | arg-m-0 ⋯ arg-m-n body-m)
;;
;; Defines a function by cases. Each case is a list of argument patterns
;; followed by an expression. Cases are separated by the string “|”. If the
;; function is called with arguments that do not match any case, it throws
;; an exception.

macro.fn:
  (fn* args
    `[closure {} (case $args
      ~@(flat-map (fn1 pat `[~(quote (init pat)) ~(last pat)])
                  (split '| args))
      args (throw {err: “no pattern match for arguments”, args}))])
